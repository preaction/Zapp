<%
    use Mojo::Loader qw( data_section );
    use Zapp::Util qw( get_path_from_data );
    use Text::Balanced qw( extract_delimited );
    layout 'zapp';
    my $plan = stash( 'plan' ) // {};
%>

<style>
/********************************
 * Auto-grow textarea from https://css-tricks.com/the-cleanest-trick-for-autogrowing-textareas/
 * Markup:
 * <div class="grow-wrap">
 *   <textarea name="text" id="text" onInput="this.parentNode.dataset.replicatedValue = this.value"></textarea>
 * </div>
 */
.grow-wrap {
  /* easy way to plop the elements on top of each other and have them both sized based on the tallest one's height */
  display: grid;
}
.grow-wrap::after {
  /* Note the weird space! Needed to preventy jumpy behavior */
  content: attr(data-replicated-value) " ";

  /* This is how textarea text behaves */
  white-space: pre-wrap;

  /* Hidden from view, clicks, and screen readers */
  visibility: hidden;
}
.grow-wrap > textarea {
  /* You could leave this, but after a user resizes, then it ruins the auto sizing */
  resize: none;

  /* Firefox shows scrollbar on growth, you can hide like this. */
  overflow: hidden;
}
.grow-wrap > textarea,
.grow-wrap::after {
  /* Identical styling required!! */
  border: 1px solid black;
  padding: 0.5rem;
  font: inherit;

  /* Place on top of each other */
  grid-area: 1 / 1 / 2 / 2;
}

/**************************************************************************************
 * Zapp form classes for use by task arg forms
 */
[data-zapp-if] {
    display: none;
}
[data-zapp-if].zapp-visible {
    display: block;
}

</style>

%# Form for a single test
% my $test_tmpl = begin
    % my ( $i, $test ) = @_;
    <div class="form-row test-form">
        <input type="hidden" name="tests[<%= $i %>].test_id" value="<%= $test->{test_id} // '' %>" />
        <div class="col">
            <label for="tests[<%= $i %>].expr">Expression</label>
            <input type="text" name="tests[<%= $i %>].expr" value="<%= $test->{expr} %>" class="form-control">
        </div>
        <div class="col-auto align-self-end">
            <select name="tests[<%= $i %>].op" class="form-control">
                <option value="==" <%= $test->{op} eq '==' ? 'selected' : '' %>>==</option>
                <option value="!=" <%= $test->{op} eq '!=' ? 'selected' : '' %>>!=</option>
                <option value="&gt;" <%= $test->{op} eq '>' ? 'selected' : '' %>>&gt;</option>
                <option value="&lt;" <%= $test->{op} eq '<' ? 'selected' : '' %>>&lt;</option>
            </select>
        </div>
        <div class="col">
            <label for="tests[<%= $i %>].value">Value</label>
            <input type="text" name="tests[<%= $i %>].value" value="<%= $test->{value} %>" class="form-control">
        </div>
        <div class="col-auto align-self-end">
            <button type="button" class="test-remove btn btn-danger">-</button>
        </div>
    </div>
% end

%# Form for saving results
% my $result_tmpl = begin
    % my ( $i, $result ) = @_;
    <div class="form-row result-form">
        <div class="col">
            <label for="results[<%= $i %>].name">Name</label>
            <input type="text" name="results[<%= $i %>].name" value="<%= $result->{name} %>" class="form-control">
        </div>
        <div class="col-auto align-self-end">
            <span class="form-control-plaintext">=</span>
        </div>
        <div class="col">
            <label for="results[<%= $i %>].expr">Expression</label>
            <input type="text" name="results[<%= $i %>].expr" value="<%= $result->{expr} %>" class="form-control">
        </div>
        <div class="col-auto align-self-end">
            <button type="button" class="result-remove btn btn-danger">-</button>
        </div>
    </div>
% end

%# The form for the main task fields
% my $task_tmpl = begin
    % my $task = shift;
    <div class="task-form">
        <input type="hidden" name="task_id" value="<%= $task->{task_id} // '' %>" />
        <input type="hidden" name="class" value="<%= $task->{class} %>" />
        <header class="form-row align-items-center">
            <h3 class="col-auto mb-0">
                <label for="name"><%= ( $task->{class} // '' ) =~ s/^Zapp::Task:://r %>:</label>
            </h3>
            <div class="col">
                %= text_field "name", $task->{name}, placeholder => 'Task Name', class => 'form-control'
            </div>
        </header>
        <!-- XXX: support markdown -->
        <div class="grow-wrap">
            <%= text_area "description", $task->{description}, class => 'form-control',
                oninput => 'this.parentNode.dataset.replicatedValue = this.value',
                placeholder => 'Task description',
            %>
        </div>

        <div class="d-flex my-2 task-tabs">
            <ul class="col-auto flex-column nav nav-pills task-tabs-nav" role="tablist">
                <li class="nav-item">
                    <a class="args-tab nav-link active" href="#">Config</a>
                </li>
                <li class="nav-item">
                    <a class="tests-tab nav-link" href="#">
                        Tests
                        (<span class="tests-count">
                            <%= scalar @{$task->{tests}} %>
                        </span>)
                    </a>
                </li>
                <li class="nav-item">
                    <a class="results-tab nav-link" href="#">
                        Results
                        (<span class="results-count">
                            <%= scalar @{$task->{results}} %>
                        </span>)
                    </a>
                </li>
            </ul>

            <div class="col tab-content task-tabs-content">
                <section class="tab-pane show active all-args">
                    <div data-args-form></div>
                </section>

                <section class="tab-pane all-tests">
                    <ul class="tests list-unstyled">
                    % for my $i ( 0 .. $#{$task->{tests}} ) {
                        <li><%= $test_tmpl->( $i, $task->{tests}[ $i ] ) %></li>
                    % }
                    </ul>
                    <button class="test-add btn btn-secondary" type="button">
                        <i class="fa fa-plus"></i> Add Test
                    </button>
                </section>

                <section class="tab-pane all-results">
                    <ul class="results list-unstyled">
                    % for my $i ( 0 .. $#{$task->{results}} ) {
                        <li><%= $result_tmpl->( $i, $task->{results}[ $i ] ) %></li>
                    % }
                    </ul>
                    <button class="result-add btn btn-secondary" type="button">
                        <i class="fa fa-plus"></i> Add Result
                    </button>
                </section>
            </div>
        </div>

    </div>
% end

%# The form for plan inputs
% my $input_tmpl = begin
    % my ( $input_num, $input ) = @_;

    <div class="input-form form-row">
        <div class="col-auto">
            <label for="input[<%= $input_num %>].name">Name</label>
            %= text_field "input[$input_num].name", $input->{name}, placeholder => 'Name', class => 'form-control'
        </div>
        <div class="col-auto">
            <!-- Type is hidden so that in the future we can have different
                input elements for different types. That is much easier if we do not
                have to be able to mutate the form (though, [data-zapp-if] could
                solve that problem...) -->
            %= hidden_field "input[$input_num].type", $input->{type}
            <label>Type</label>
            <span class="input-type form-control-plaintext"><%= $input->{type} %></span>
        </div>
        <div class="col">
            <label for="input[<%= $input_num %>].default_value">Default Value</label>
            %= text_field "input[$input_num].default_value", $input->{default_value}, placeholder => 'Default value', class => 'form-control'
        </div>
        <div class="col-auto align-self-end">
            <button type="button" class="delete input-remove btn btn-danger">-</button>
        </div>
    </div>
    <div class="form-row">
        <div class="col">
            <label for="input[<%= $input_num %>].description">Description</label>
            <div class="grow-wrap">
                <!-- XXX: support markdown -->
                <%= text_area "input[$input_num].description", $input->{description},
                    oninput => 'this.parentNode.dataset.replicatedValue = this.value',
                    placeholder => 'Input description',
                %>
            </div>
        </div>
    </div>
% end

<template id="task-form">
    %= $task_tmpl->( {} )
</template>
<template id="test-form">
    %= $test_tmpl->( 0, { op => '=='} )
</template>
<template id="result-form">
    %= $result_tmpl->( 0, {} )
</template>
<template id="input-form">
    %= $input_tmpl->( 0, {} )
</template>

% for my $class ( @{ stash 'tasks' } ) {
    <template data-class="<%= $class %>">
        %= include inline => data_section( $class, 'args.html.ep' )
    </template>
% }

%= form_for 'zapp.save_plan', id => 'plan', begin
    <header class="form-row align-items-center">
        <h1 class="col-auto mb-0">Edit Plan</h1>
        %= link_to 'zapp.list_plans', class => 'btn btn-secondary', begin
            <i class="fa fa-arrow-left"></i> Back to Plans
        % end
    </header>
    % if ( my $errors = stash 'errors' ) {
        <div class="alert alert-danger">
            There are some errors in your plan.
            <ul>
                % for my $error ( @$errors ) {
                <li><%== $error->{error} %></li>
                % }
            </ul>
        </div>
    % }
    <div class="form-group">
        <label class="mb-1" for="name">Plan Name</label>
        <input id="name" class="form-control" name="name" type="text" placeholder="Plan Name" value="<%= $plan->{name} %>">
        <!-- XXX: Add folders to organize plans -->
    </div>
    <div class="form-group">
        <label for="description">Plan Description</label>
        <div class="grow-wrap">
            <%= text_area "description", $plan->{description}, id => 'description', class => 'form-control',
                oninput => 'this.parentNode.dataset.replicatedValue = this.value',
                placeholder => 'Plan description',
            %>
        </div>
    </div>

    <div class="input-container my-2">
        <h2 class="border-bottom border-secondary">Input</h2>
        <ul id="all-inputs" class="list-unstyled">
            % for my $input_num ( 0 .. $#{ $plan->{inputs} } ) {
                % my $input = $plan->{inputs}[ $input_num ];
                <li>
                    %= $input_tmpl->( $input_num, $input )
                </li>
            % }
        </ul>
        <select class="add-input form-control col-auto">
            <option>Add Input...</option>
            % for my $type ( qw( string number integer boolean ) ) {
                %= tag option => ( value => $type ), ucfirst $type
            % }
        </select>
    </div>

    <div class="task-container my-2">
        <h2 class="border-bottom border-secondary">Tasks</h2>
        <div id="all-tasks">
            <% for my $task_num ( 0 .. $#{ $plan->{tasks} } ) { %>
                <section data-task-form class="task pt-2 border-bottom border-secondary"><%
                    my $task = $plan->{tasks}[ $task_num ];
                    my $args_form = include inline => data_section( $task->{class}, 'args.html.ep' ), args => $task->{args};
                    my $args_dom = Mojo::DOM->new( $args_form );
                    $args_dom->find( '[data-zapp-if]' )->each(
                        sub {
                            my ( $el ) = @_;
                            my ( $lhs, $op, $rhs ) = split /\s*(==|!=|>|<|>=|<=|eq|ne|gt|lt|ge|le)\s*/, $el->attr( 'data-zapp-if' ), 3;
                            #; say "Expr: " . $el->attr( 'data-zapp-if' );
                            #; say "LHS: $lhs; OP: $op; RHS: $rhs";
                            if ( !$op ) {
                                # Boolean LHS
                                my ( $false, $path ) = $lhs =~ /^(!)?\s*(\S+)/;
                                my $value = get_path_from_data( $path, $task->{args} );
                                if ( ( !$false && $value ) || ( $false && !$value ) ) {
                                    #; say "False: $false; Value: $value";
                                    $el->attr( class => join ' ', $el->attr( 'class' ), 'zapp-visible' );
                                }
                            }
                            else {
                                my ( $lhs_value, $rhs_value );
                                if ( $lhs_value = extract_delimited( $lhs ) ) {
                                    $lhs_value =~ s/^['"`]|['"`]$//g;
                                }
                                else {
                                    $lhs_value = get_path_from_data( $lhs, $task->{args} );
                                }
                                if ( $rhs_value = extract_delimited( $rhs ) ) {
                                    $rhs_value =~ s/^['"`]|['"`]$//g;
                                }
                                else {
                                    $rhs_value = get_path_from_data( $rhs, $task->{args} );
                                }

                                my %ops = (
                                    map { $_ => eval "sub { shift $_ shift }" } qw( == != > < >= <= eq ne gt lt ge le ),
                                );
                                #; say "LHS: $lhs_value ($lhs); OP: $op; RHS: $rhs_value ($rhs)";
                                if ( $ops{ $op } && $ops{ $op }->( $lhs_value, $rhs_value ) ) {
                                    $el->attr( class => join ' ', $el->attr( 'class' )//(), 'zapp-visible' );
                                }
                            }
                        },
                    );

                    $args_dom->find( 'input,select,textarea' )->each(
                        sub {
                            my ( $el ) = @_;
                            my $name = $el->attr( 'name' );
                            my $joiner = $name =~ /^\[/ ? '' : '.';
                            $el->attr( name => join $joiner, 'args', $name );
                            $el->attr( id => $el->attr( 'name' ) );
                        },
                    );
                    $args_dom->find( 'label' )->each(
                        sub {
                            my ( $el ) = @_;
                            my $for = $el->attr( 'for' );
                            my $joiner = $for =~ /^\[/ ? '' : '.';
                            $el->attr( for => join $joiner, 'args', $for );
                        },
                    );

                    my $task_form = $task_tmpl->( $task );
                    my $task_dom = Mojo::DOM->new( $task_form );
                    $task_dom->at( '[data-args-form]' )->replace( $args_dom );
                    $task_dom->find( 'input,select,textarea' )->each(
                        sub {
                            my ( $el ) = @_;
                            $el->attr( name => 'task[' . $task_num . '].' . $el->attr( 'name' ) );
                            $el->attr( id => $el->attr( 'name' ) );
                        },
                    );
                    $task_dom->find( 'label' )->each(
                        sub {
                            my ( $el ) = @_;
                            $el->attr( for => 'task[' . $task_num . '].' . $el->attr( 'for' ) );
                        },
                    );
                    %><%== $task_dom %></section><%
            } %>
        </div>

        <div class="my-3">
            <select class="add-task form-control">
                <option>Add Task...</option>
                % for my $class ( @{ stash 'tasks' } ) {
                    %= tag option => ( value => $class ), $class =~ s/Zapp::Task:://r
                % }
            </select>
        </div>
    </div>

    <button name="save-plan" class="btn btn-primary">Save Plan</button>
% end

%= javascript begin
function delegateEvent( eventName, elementSelector, handler ) {
    document.addEventListener(eventName, function(e) {
        for (var target = e.target; target && target != this; target = target.parentNode) {
            if (target.matches(elementSelector)) {
                handler.call(target, e);
                break;
            }
        }
    }, false);
}

function addTask( event ) {
    // XXX: Focus on task name element after adding form
    var inputSelector = 'input,select,textarea',
        sel = event.target,
        opt = sel.options[ sel.selectedIndex ],
        type = opt.innerText,
        cls = opt.value,
        allTasks = document.querySelector( '#all-tasks' ),
        beforeTask = sel.closest( '[data-task-form]' ),
        taskIdx = beforeTask ? allTasks.indexOf( beforeTask ) : allTasks.childElementCount,
        taskTmpl = document.querySelector( 'template#task-form' ).content.cloneNode(true),
        taskForm = document.createElement( 'div' ),
        argsTmpl = document.querySelector( `[data-class="${cls}"]` ).content,
        argsForm = argsTmpl.cloneNode(true);
    sel.selectedIndex = 0;

    var argsInputs = argsForm.querySelectorAll( inputSelector );
    argsInputs.forEach( function ( el ) {
        var sep = el.name.startsWith( '[' ) ? '' : '.';
        el.name = `args${sep}${el.name}`;
        el.id = el.name;
    } );

    var argsLabels = argsForm.querySelectorAll( 'label' );
    argsLabels.forEach( function ( el ) {
        var sep = el.attributes.for.value.startsWith( '[' ) ? '' : '.';
        el.attributes.for.value = `args${sep}${el.attributes.for.value}`;
    } );

    taskForm.dataset.taskForm = true;
    taskForm.appendChild( taskTmpl );
    taskForm.querySelector( '[data-args-form]' ).replaceWith( argsForm );
    var taskTypeLabel = taskForm.querySelector( 'label[for=name]' );
    taskTypeLabel.innerHTML = type;
    var taskClassInput = taskForm.querySelector( 'input[name=class]' );
    taskClassInput.value = cls;
    var taskInputs = taskForm.querySelectorAll( inputSelector );
    taskInputs.forEach( function ( el ) {
        el.name = `task[${taskIdx}].${el.name}`;
        el.id = el.name;
    } );
    var taskLabels = taskForm.querySelectorAll( 'label' );
    taskLabels.forEach( function ( el ) {
        el.attributes.for.value = `task[${taskIdx}].${el.attributes.for.value}`;
    } );

    if ( beforeTask ) {
        beforeTask.insertAdjacentElement( 'beforebegin', taskForm );
    }
    else {
        allTasks.appendChild( taskForm );
    }

    if ( beforeTask ) {
        // XXX: Re-index all subsequent tasks
    }
}

function removeTask( event ) {
}

function moveTask( event ) {
}

function addTest( event ) {
    // Clone the blank row from the template
    var button = event.target,
        list = button.previousElementSibling,
        task = button.closest( '.task-form' ),
        newTest = document.querySelector( 'template#test-form' ).content.cloneNode(true),
        newIndex = list.querySelectorAll('li').length,
        // Find an input so we can see which task we're in
        nameAttr = task.querySelector( 'input' ).attributes.getNamedItem( 'name' ).value,
        taskIndex = nameAttr.substring( nameAttr.indexOf('[') + 1, nameAttr.indexOf(']') );

    // Reset expr, op, value
    newTest.querySelectorAll( 'input,select' ).forEach( function (el) {
        if ( el.tagName == 'SELECT' ) {
            el.selectedIndex = 0;
        }
        else {
            el.value = '';
        }
        el.name = el.name.replace( /tests\[\d+\]/, 'task[' + taskIndex + '].tests[' + newIndex + ']' );
        el.id = el.name;
    } );
    // XXX: Labels

    // Append
    var newRow = document.createElement( 'li' );
    newRow.appendChild( newTest );
    list.appendChild( newRow );

    // XXX: Focus test expression field
    // XXX: Increment test count
}

function removeTest( event ) {
    var button = event.target,
        row = button.closest( '.test-form' ).parentNode,
        list = row.parentElement;

    row.parentNode.removeChild( row );
    // Reset indexes in remaining test rows
    list.querySelectorAll( 'li' ).forEach( function (row, i) {
        row.querySelectorAll( 'input,select' ).forEach( function (el) {
            el.name = el.name.replace( /tests\[\d+\]/, 'tests[' + i + ']' );
            el.id = el.name;
        });
        // XXX: Labels
    } );
    // XXX: Decrement test count
}

function addResult( event ) {
    // Clone the blank row from the template
    var button = event.target,
        list = button.previousElementSibling,
        task = button.closest( '.task-form' ),
        newResult = document.querySelector( 'template#result-form' ).content.cloneNode(true),
        newIndex = list.querySelectorAll('li').length,
        // Find an input so we can see which task we're in
        nameAttr = task.querySelector( 'input' ).attributes.getNamedItem( 'name' ).value,
        taskIndex = nameAttr.substring( nameAttr.indexOf('[') + 1, nameAttr.indexOf(']') );

    // Reset expr, op, value
    newResult.querySelectorAll( 'input,select' ).forEach( function (el) {
        if ( el.tagName == 'SELECT' ) {
            el.selectedIndex = 0;
        }
        else {
            el.value = '';
        }
        el.name = el.name.replace( /results\[\d+\]/, 'task[' + taskIndex + '].results[' + newIndex + ']' );
        el.id = el.name;
    } );
    // XXX: Labels

    // Append
    var newRow = document.createElement( 'li' );
    newRow.appendChild( newResult );
    list.appendChild( newRow );

    // XXX: Focus result name field
    // XXX: Increment results count
}

function removeResult( event ) {
    var button = event.target,
        row = button.closest( '.result-form' ).parentNode,
        list = row.parentElement;

    row.parentNode.removeChild( row );
    // Reset indexes in remaining test rows
    list.querySelectorAll( 'li' ).forEach( function (row, i) {
        row.querySelectorAll( 'input,select' ).forEach( function (el) {
            el.name = el.name.replace( /results\[\d+\]/, 'results[' + i + ']' );
            el.id = el.name;
        });
        // XXX: Labels
    } );
    // XXX: Decrement result count
}

function addInput( event ) {
    // Clone the blank row from the template
    var select = event.target,
        inputType = select.options[ select.selectedIndex ].value,
        list = select.previousElementSibling,
        input = select.parentNode,
        newInput = document.querySelector( 'template#input-form' ).content.cloneNode(true),
        newIndex = list.querySelectorAll('li').length;

    // Set type
    newInput.querySelector( '[name="input[0].type"]' ).attributes.getNamedItem( 'value' ).value = inputType;
    newInput.querySelector( '.input-type' ).innerHTML = inputType;

    // Fix indexes
    newInput.querySelectorAll( 'input,select,textarea' ).forEach( function (el) {
        el.name = el.name.replace( /input\[\d+\]/, 'input[' + newIndex + ']' );
        el.id = el.name;
    } );

    // Append
    var newRow = document.createElement( 'li' );
    newRow.appendChild( newInput );
    list.appendChild( newRow );

    select.selectedIndex = 0;
    // XXX: Focus input name field
}

function removeInput( event ) {
    event.preventDefault();
    var button = event.target,
        row = button.closest( '.input-form' ).parentElement,
        list = row.parentElement;

    row.parentNode.removeChild( row );
    // Reset indexes in remaining test rows
    list.querySelectorAll( 'li' ).forEach( function (row, i) {
        row.querySelectorAll( 'input,select,textarea' ).forEach( function (el) {
            el.name = el.name.replace( /input\[\d+\]/, 'input[' + i + ']' );
            el.id = el.name;
        });
    } );
}

function checkZappExpressions( event ) {
    var match = event.target.name.match( /task\[\d+\]\.args\./ );
    if ( !match ) return;
    var task = event.target.closest( '[data-task-form]' ),
        args = {};
    task.querySelectorAll( '[name^="' + match[0] + '"]').forEach( function ( el ) {
        var name = el.name, key = name.replace( match[0], '' );
        args[ key ] = el.value;
    } );

    // Find all data-zapp-if
    task.querySelectorAll( '[data-zapp-if]' ).forEach( function ( el ) {
        var expr = el.dataset.zappIf,
            exprMatch = expr.match( /\s*(.+?)\s*(==|!=|>|<|>=|<=|eq|ne|gt|lt|ge|le)\s*(.+)/ );
        if ( exprMatch ) {
            var lhs = exprMatch[1],
                op = exprMatch[2],
                rhs = exprMatch[3];

            if ( lhs.match( /^['"]/ ) ) {
                lhs = lhs.substring( 1, lhs.length-1 );
            }
            else if ( !lhs.match( /^\d/ ) ) {
                lhs = args[ lhs ];
            }

            if ( rhs.match( /^['"]/ ) ) {
                rhs = rhs.substring( 1, rhs.length-1 );
            }
            else if ( !rhs.match( /^\d/ ) ) {
                rhs = args[ rhs ];
            }

            var opFunc = {},
                ops = [
                    '==', '!=', '>', '<', '>=', '<=',
                    'eq', 'ne', 'gt', 'lt', 'ge', 'le'
                ],
                opMap = {
                    eq: '==', ne: '!=',
                    gt: '>', lt: '<',
                    ge: '>=', le: '<='
                };
            ops.forEach( function ( op ) {
                eval( "opFunc[ op ] = function ( lhs, rhs ) { return lhs " + ( opMap[op] || op ) + " rhs; }" );
            } );
            if ( opFunc[ op ] && opFunc[ op ]( lhs, rhs ) ) {
                el.classList.add( 'zapp-visible' );
            }
            else {
                el.classList.remove( 'zapp-visible' );
            }
        }
        else {
            // Look for leading !
            var invert = expr.match( /^!/ );
            if ( invert ) {
                expr = expr.replace( /^!/, '' );
            }
            // Find arg value and check for booleans
            if ( ( !invert && args[ expr ] ) || ( invert && !args[ expr ] ) ) {
                el.classList.add( 'zapp-visible' );
            }
            else {
                el.classList.remove( 'zapp-visible' );
            }
        }
    });

}

function changeTaskTab( event ) {
    event.preventDefault();
    var tabNavItem = event.target,
        tabNavListItem = tabNavItem.parentNode,
        tabContainer = tabNavItem.closest( '.task-tabs' ),
        tabNav = tabContainer.querySelector( '.task-tabs-nav' ),
        tabIndex = Array.prototype.indexOf.call( tabNav.childNodes, tabNavListItem ),
        tabPaneContainer = tabContainer.querySelector( '.task-tabs-content' );
    tabNav.querySelectorAll( '.task-tabs-nav .active' ).forEach( function (el) {
        el.classList.remove( 'active' );
    } );
    tabNav.childNodes[ tabIndex ].querySelector('a').classList.add( 'active' );
    tabPaneContainer.querySelectorAll( '.task-tabs-content > .tab-pane.show.active' ).forEach( function (el) {
        el.classList.remove( 'show', 'active' );
    } );
    tabPaneContainer.childNodes[ tabIndex ].classList.add( 'show', 'active' );
}

document.addEventListener('DOMContentLoaded', function ( event ) {
    document.querySelectorAll( '.grow-wrap textarea' ).forEach( function (el) {
        // This causes a slight blink when the DOM is loaded. It would
        // be nice if we could remove this and have the textarea start
        // the correct size for the content.
        el.parentNode.dataset.replicatedValue = el.value;
    } );
    delegateEvent( 'change', 'select.add-task', addTask );
    delegateEvent( 'click', 'button.test-add', addTest );
    delegateEvent( 'click', 'button.test-remove', removeTest );
    delegateEvent( 'click', 'button.result-add', addResult );
    delegateEvent( 'click', 'button.result-remove', removeResult );
    delegateEvent( 'change', '*', checkZappExpressions );
    delegateEvent( 'click', '.task-tabs > .task-tabs-nav .nav-link', changeTaskTab );
    delegateEvent( 'change', 'select.add-input', addInput );
    delegateEvent( 'click', 'button.input-remove', removeInput );
});

% for my $js ( grep !!$_, map { data_section( $_, 'args.js.ep' ) } @{ stash 'tasks' } ) {
    %= include inline => $js
% }
% end
